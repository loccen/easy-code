# 易码网 (Easy Code) 项目开发指导

## 项目概述
易码网是一个综合性源代码交易平台，提供双轨上架系统、一键部署、灵活支付适配器、积分系统等功能。

## 技术架构
- **前端**: Next.js 14 + TypeScript + Tailwind CSS
- **后端**: Supabase (PostgreSQL + Auth + Storage + Edge Functions)
- **部署**: Docker + Kubernetes
- **支付**: 多适配器支持 (支付宝、微信、Stripe等)
- **AI服务**: 本地工具集成

## 开发原则

### 1. 架构简化原则
- 初期将大部分服务集成到主应用中
- 仅分离部署编排器服务
- 延迟支付服务集成
- AI容器化手动处理

### 2. 数据库管理
- 使用 Supabase API 直接操作配置
- 先操作 → 调试 → 更新脚本
- 包含所有 RLS 策略修复
- 更新数据库设置脚本以简化未来部署

### 3. 开发流程
- **需求分析** → **架构设计** → **原型设计** → **编码实现**
- 所有文档统一放在 `docs/` 目录下，按类型分子目录
- 频繁使用 Playwright 进行应用测试
- 测试通过后才能进入下一个开发任务

### 4. 测试策略
- 每次编码后立即测试
- 使用 Playwright 进行端到端测试
- 我已经运行了开发服务器，访问地址是http://localhost:3000，除非你打开浏览器无法访问，否则不需要再次启动服务器
- 确保所有功能符合预期
- 测试未通过不允许进入下一任务

### 5. 代码质量
- 使用包管理器而非手动编辑配置文件
- 保持代码简洁和可维护性
- 编写单元测试和集成测试
- 提交代码前，必须运行build和lint命令，解决所有编译错误和告警
- 择机进行 Git 提交，避免积累过多改动，请务必记住，当前的改动未完成测试前，不允许提交。

### 6. TypeScript 和编译错误处理

#### 6.1 类型定义最佳实践
**问题**: 使用 `any` 类型导致 ESLint 错误和类型安全问题
**解决方案**:
- 始终为数据结构定义具体的 TypeScript 接口
- 避免使用 `any` 类型，使用具体类型或联合类型
- 为 API 响应、组件 props、状态变量定义明确类型

```typescript
// ❌ 错误做法
const [searchResults, setSearchResults] = useState<any[]>([]);
const [selectedUser, setSelectedUser] = useState<any>(null);

// ✅ 正确做法
interface UserSearchResult {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  status: UserStatus;
  created_at: string;
}

const [searchResults, setSearchResults] = useState<UserSearchResult[]>([]);
const [selectedUser, setSelectedUser] = useState<UserWithCredits | null>(null);
```

#### 6.2 Supabase 查询类型处理
**问题**: Supabase 关联查询返回的数据结构与 TypeScript 接口定义不匹配
**解决方案**:
- 理解 Supabase 关联查询的返回格式（通常是数组）
- 创建数据转换函数来匹配 TypeScript 接口
- 在 API 函数中进行类型转换

```typescript
// ❌ 问题：期望单个对象，但 Supabase 返回数组
interface AdminCreditOperation {
  users: { username: string; email: string; } | null;
}

// ✅ 解决方案：数据转换
const { data, error } = await supabase
  .from('credit_transactions')
  .select('*, users!inner(username, email)');

const transformedData = (data || []).map(item => ({
  ...item,
  users: Array.isArray(item.users) && item.users.length > 0 ? item.users[0] : null
}));
```

#### 6.3 UI 组件类型安全
**问题**: 使用不存在的组件属性值导致编译错误
**解决方案**:
- 使用组件前检查其 TypeScript 定义
- 不要假设组件支持某些属性值
- 建立项目内 UI 组件的使用文档

```typescript
// ❌ 错误：假设 Button 支持 'default' variant
<Button variant="default">按钮</Button>

// ✅ 正确：使用实际支持的 variant
<Button variant="primary">按钮</Button>
```

#### 6.4 null 安全处理
**问题**: 可能为 null 的对象访问导致编译错误
**解决方案**:
- 使用可选链操作符 (`?.`) 和空值合并操作符 (`??`)
- 在必要时使用非空断言操作符 (`!`)，但要确保逻辑正确
- 在函数开始处进行参数验证

```typescript
// ❌ 错误：直接访问可能为 null 的对象
const credits = selectedUser.credits.available_credits;

// ✅ 正确：使用可选链和空值合并
const credits = selectedUser?.credits?.available_credits ?? 0;

// ✅ 或者在验证后使用非空断言
if (!selectedUser) {
  setError('请先选择用户');
  return;
}
const credits = selectedUser!.credits?.available_credits ?? 0;
```

#### 6.5 开发流程检查清单
**编码前**:
- [ ] 定义所需的 TypeScript 接口
- [ ] 检查使用的 UI 组件类型定义
- [ ] 了解 Supabase 查询返回的数据结构

**编码中**:
- [ ] 避免使用 `any` 类型
- [ ] 为状态变量和函数参数添加类型注解
- [ ] 处理可能为 null/undefined 的值

**编码后**:
- [ ] 运行 `npm run lint` 检查代码质量
- [ ] 运行 `npm run build` 检查 TypeScript 编译
- [ ] 解决所有类型错误和警告
- [ ] 进行功能测试验证

#### 6.6 常见错误模式和预防
1. **数据转换错误**: 在 API 层进行数据格式转换，确保返回类型与接口匹配
2. **组件属性错误**: 建立组件使用文档，记录支持的属性值
3. **null 引用错误**: 建立统一的错误处理模式，在函数入口进行参数验证
4. **类型推断失败**: 显式添加类型注解，不依赖 TypeScript 的类型推断

## 目录结构
```
easy-code/
├── docs/                    # 项目文档
│   ├── requirements/        # 需求分析
│   ├── architecture/        # 架构设计
│   ├── prototypes/          # 原型设计
│   └── deployment/          # 部署文档
├── src/                     # 源代码
├── tests/                   # 测试文件
├── scripts/                 # 脚本文件
└── deployment/              # 部署配置
```

## Git 提交规范
- feat: 新功能
- fix: 修复bug
- docs: 文档更新
- style: 代码格式调整
- refactor: 代码重构
- test: 测试相关
- chore: 构建过程或辅助工具的变动

## Supabase 操作流程
1. 使用 Supabase API 直接操作
2. 进行调试和测试
3. 记录操作步骤
4. 更新对应脚本

## 部署策略
- Docker 容器化
- Kubernetes 编排
- 一键部署支持
- 环境配置管理

## 注意事项
- 所有回复使用中文
- 遇到反复失败的命令时停下来让用户手动执行
- 善用可用工具
- 保持频繁的 Git 提交
- 项目未初始化时先进行仓库初始化